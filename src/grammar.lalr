use super::ast; // super instead of self because lalrpop wraps this in an internal module
use super::spans;


grammar(ctx: &mut spans::SpanMaker<'input>);

Ident: String = <r"[a-z_]\w*"> => String::from(<>);
Tag: String = <r"`[A-Z]\w*"> => String::from(<>);

IntLiteral: String = <r"-?(?:0|[1-9][[:digit:]]*)"> => String::from(<>);
FloatLiteral: String =
    <r"-?(?:0|[1-9][[:digit:]]*)\.[[:digit:]]*(?:[eE]-?[[:digit:]]+)?"> => String::from(<>);
StringLiteral: String =
    <r#""[^\\"]*(?:\\[tn'"\\][^\\"]*)*""#> => String::from(<>);


// make sure __proto__ is not considered a valid identifier
Illegal = "__proto__";

SepList<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};
SepListOpt<T, Sep>: Vec<T> = {
    SepList<T, Sep>,
    => Vec::new(),
};

Spanned<T>: spans::Spanned<T> = {
    <l: @L> <val: T> <r: @R> => (val, ctx.span(l, r))
};

VarOrLiteral: Box<ast::Expr> = {
    Spanned<Ident> => Box::new(
        match <>.0.as_str() {
            "false" | "true" => ast::Expr::Literal(ast::Literal::Bool, <>),
            _ => ast::Expr::Variable(<>)
        }
    ),

    Spanned<FloatLiteral> => Box::new(ast::Expr::Literal(ast::Literal::Float, <>)),
    Spanned<IntLiteral> => Box::new(ast::Expr::Literal(ast::Literal::Int, <>)),
    Spanned<StringLiteral> => Box::new(ast::Expr::Literal(ast::Literal::Str, <>)),
}

If: Box<ast::Expr> = {
    "if" <Spanned<Expr>> "then" <Expr> "else" <Expr> => Box::new(ast::Expr::If(<>)),
}

FuncSub = "fun" <Ident> "->" <Expr>;
FuncDef: Box<ast::Expr> = {
    Spanned<FuncSub> => Box::new(ast::Expr::FuncDef(<>)),
}
Call: Box<ast::Expr> = {
    Spanned<CallExpr> CaseExpr => {
        let ((lhs, span), rhs) = (<>);
        Box::new(ast::Expr::Call(lhs, rhs, span))
    }
}


KeyPairExpr = {
    <Spanned<Ident>> "=" <Expr>,
}
RecordSub = "{" <SepListOpt<KeyPairExpr, ";">> "}";
Record: Box<ast::Expr> = {
    Spanned<RecordSub> => Box::new(ast::Expr::Record(<>)),
}
FieldAccess: Box<ast::Expr> = {
    <lhs: SimpleExpr> <rhs: Spanned<("." Ident)>> => Box::new(ast::Expr::FieldAccess(lhs, (rhs.0).1, rhs.1)),
}

Case: Box<ast::Expr> = {
    <Spanned<Tag>> <CaseExpr> => Box::new(ast::Expr::Case(<>)),
}

MatchPattern: ast::Pattern = {
    Tag Ident => ast::Pattern::Case(<>),
    Ident => ast::Pattern::Wildcard(<>),
}
MatchArm = {
    "|" <Spanned<MatchPattern>> "->" <CompareExpr>,
}
MatchSub = "match" <Spanned<Expr>> "with" <MatchArm+>;
Match: Box<ast::Expr> = {
    MatchSub => {
        let ((param, span), arms) = <>;
        Box::new(ast::Expr::Match(param, arms, span))
    }
}


LetLHS = {
    "let" <Ident> "=" <Expr>,
}
LetRHS = {
    "in" <Expr>,
}
Let: Box<ast::Expr> = {
    <LetLHS> <LetRHS> => Box::new(ast::Expr::Let(<>)),
}


LetRecDef = {
    <Ident> "=" <FuncDef>,
}
LetRecLHS = {
    "let" "rec" <SepList<LetRecDef, "and">>,
}
LetRec: Box<ast::Expr> = {
     <LetRecLHS> <LetRHS> => Box::new(ast::Expr::LetRec(<>)),
}


NewRef: Box<ast::Expr> = {
    Spanned<("ref" CaseExpr)> => {
        let ((_, expr), span) = <>;
        Box::new(ast::Expr::NewRef(expr, span))
    }
}
RefGet: Box<ast::Expr> = {
    "!" <Spanned<RefExpr>> => Box::new(ast::Expr::RefGet(<>))
}
RefSet: Box<ast::Expr> = {
    <Spanned<CallExpr>> ":=" <Expr> => Box::new(ast::Expr::RefSet(<>))
}


MultOpSub: (ast::OpType, ast::Op) = {
    "*" => (ast::OpType::IntOp, ast::Op::Mult),
    "/" => (ast::OpType::IntOp, ast::Op::Div),
    "*." => (ast::OpType::FloatOp, ast::Op::Mult),
    "/." => (ast::OpType::FloatOp, ast::Op::Div),
}
MultOp: Box<ast::Expr> = {
    Spanned<(Spanned<MultExpr> MultOpSub Spanned<CallExpr>)> => {
        let ((lhs, op, rhs), span) = <>;
        Box::new(ast::Expr::BinOp(lhs, rhs, op.0, op.1, span))
    },
}
AddOpSub: (ast::OpType, ast::Op) = {
    "+" => (ast::OpType::IntOp, ast::Op::Add),
    "-" => (ast::OpType::IntOp, ast::Op::Sub),
    "+." => (ast::OpType::FloatOp, ast::Op::Add),
    "-." => (ast::OpType::FloatOp, ast::Op::Sub),
    "^" => (ast::OpType::StrOp, ast::Op::Add),
}
AddOp: Box<ast::Expr> = {
    Spanned<(Spanned<AddExpr> AddOpSub Spanned<MultExpr>)> => {
        let ((lhs, op, rhs), span) = <>;
        Box::new(ast::Expr::BinOp(lhs, rhs, op.0, op.1, span))
    },
}
CmpOpSub: (ast::OpType, ast::Op) = {
    "<" => (ast::OpType::IntCmp, ast::Op::Lt),
    "<=" => (ast::OpType::IntCmp, ast::Op::Lte),
    ">" => (ast::OpType::IntCmp, ast::Op::Gt),
    ">=" => (ast::OpType::IntCmp, ast::Op::Gte),

    "<." => (ast::OpType::FloatCmp, ast::Op::Lt),
    "<=." => (ast::OpType::FloatCmp, ast::Op::Lte),
    ">." => (ast::OpType::FloatCmp, ast::Op::Gt),
    ">=." => (ast::OpType::FloatCmp, ast::Op::Gte),

    "==" => (ast::OpType::AnyCmp, ast::Op::Eq),
    "!=" => (ast::OpType::AnyCmp, ast::Op::Neq),
}
CmpOp: Box<ast::Expr> = {
    Spanned<(Spanned<AddExpr> CmpOpSub Spanned<AddExpr>)> => {
        let ((lhs, op, rhs), span) = <>;
        Box::new(ast::Expr::BinOp(lhs, rhs, op.0, op.1, span))
    },
}



SimpleExpr = {
    FieldAccess,
    Record,
    VarOrLiteral,
    "(" <Expr> ")",
}
RefExpr = {
    SimpleExpr,
    RefGet,
}
CaseExpr = {
    RefExpr,
    Case,
    NewRef,
}
CallExpr = {
    CaseExpr,
    Call,
}
MultExpr = {
    CallExpr,
    MultOp,
}
AddExpr = {
    MultExpr,
    AddOp,
}
CompareExpr = {
    AddExpr,
    CmpOp,
}
Expr = {
    CompareExpr,
    FuncDef,
    If,
    Let,
    LetRec,
    Match,
    RefSet,
}

TopLevelItem: ast::TopLevel = {
    <LetLHS> => ast::TopLevel::LetDef(<>),
    <LetRecLHS> => ast::TopLevel::LetRecDef(<>),
    <Expr> => ast::TopLevel::Expr(*<>),
}

pub Script = {
   <SepList<TopLevelItem, ";">>
}
